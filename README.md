# OperatingSystem - Lab1

##  Алокатор пам'яті загального призначення

Даний код емулює логіку роботи алокатора пам'яті загального призначеня.
Структура алокатора складається з **Header** та **Data**. **Header** - структура, де зберігається інформація про блок пам'яті. **Data** - пам'ять для зберігання даних. Алокатор використовує вказівники для переміщення по виділеній пам'яті.

#### Структура Header
#

```
struct Header
{
	uint16_t size;
	uint16_t prevSize;
	bool isAvailable;
	uint8_t alignment[3];
};
```

| size    | prevSize | isAvailable | alingment   |
|:------- |:---------|:------------|:------------|
| 2 байта | 2 байта  | 1 байт      | 3 байта     |

- **size** - розмір даного блоку
- **prevSize** - розмір попереднього блоку
- **isAvailable** - чи зайнятий даний блок
- **alingment** - масив із 3-x байтів для того, щоб **Header** дорівнював рівно 8 байтам 

#

#### Опис алгоритму

Мінімальний розмір блоку - **8 байтів + 4 байта = 12 байтів**
8 байтів - це розмір службової інформації (Header),
4 байта - це мінімальний розмір адреси пам'яті, тому що всі адреси вирівнюються по 4-х байтах.
*Що це означає?* 
- Якщо потрібно виділити 3 байти, насправді виділиться 12 = 8 + (3 + 1).
- Якщо потрібно виділити 9 байтів, насправді виділиться 20 = 8 + (9 + 3).

#

- ##### **void\* mem_alloc(size_t)**

    Дана функція виділяє новий блок та повертає вказівник на нього. За допомогою циклу шукається перший підходящий блок. Розмір блоку звісно ж вирівнюється на межу в 4 байти. Якщо знайдений блок завеликий, він розбивається на два. В найкращому випадку пошук здійснюється за **О(1)** (перший блок), в найгіршому за **О(N)** (останній N-й блок)

- ##### **void\* mem_realloc(void\*, size_t)**

    Дана функція змінює розмір блоку та повертає вказівник на блок. У випадку, коли новий розмір менший за поточний, змінюється розмір даного блоку, тобто інформація не переноситься в інші блоки. Якщо потрібний розмір більший за поточний розмір блоку, то перевіряється чи вільні сусідні блоки(якщо вони є). Якщо вони вільні та вистачає байтів для створення нового блоку, то вони об'єднуються і створюється один блок. У разі, якщо сусідні блоки не вільні або не вистачає їхнього розміру, алгоритм проводить пошук по всій виділеній області в пошуку блоку, який задовольняє потрібний розмір.

- ##### **void mem_free(void\*)**

    Функція приймає адресу пам'яті та звільняє блок пам'яті з відповідною адресою.
    
- ##### **void mem_dump()**

    Виводить на консоль інформацію про стан блоків пам'яті.
    
#

#### Приклад роботи


